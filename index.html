<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12星座 黏另一半 (假影片播放器 含粒子下載 - 含文字邊距)</title>
    <style>
        body {
            background-color: black; /* Black background for the whole page */
            color: white; /* Default text color */
            font-family: sans-serif; /* Readable font */
            margin: 0; /* Remove default body margin */
            padding: 20px; /* Add some padding around content */
            padding-bottom: 80px; /* Add padding at the bottom to prevent content hiding behind fixed button */
            box-sizing: border-box;
            display: flex; /* Use flexbox to center the player */
            justify-content: center; /* Center horizontally */
            align-items: flex-start; /* Align items to the start (top) so player isn't always vertically centered */
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            overflow-y: auto; /* Add scroll if content overflows */
            overflow-x: hidden; /* Hide horizontal scrollbar if player is slightly too wide */
        }

        .fake-video-player-container {
            max-width: 350px; /* Set a max width for the player (typical for 9:16 on desktop) */
            width: 90%; /* Player takes up 90% of container width, up to max-width */
            background-color: #222; /* Dark background for the player frame */
            border-radius: 15px; /* Rounded corners for the player */
            overflow: hidden; /* Hide anything that spills out */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); /* Add a subtle shadow */
            display: flex; /* Arrange screen and controls vertically */
            flex-direction: column;
            margin-top: 20px; /* Add some margin at the top */
        }

        .video-screen {
            position: relative;
            width: 100%;
            aspect-ratio: 9 / 16; /* KEEPS 9:16 */
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .video-content {
            display: none; /* The original HTML text content - HIDDEN */
        }

        .fake-controls {
            background-color: #333;
            height: 40px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
            z-index: 10;
        }

        .fake-controls .control-placeholder {
            width: 20px;
            height: 20px;
            background-color: #555;
            border-radius: 3px;
        }

        .fake-controls .play-placeholder {
             width: 25px;
             height: 25px;
             background-color: #eee;
             border-radius: 50%;
        }

        .download-section {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 0;
            text-align: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        #downloadButton {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        #downloadButton:hover:not(:disabled) {
            background-color: #0056b3;
        }

         #downloadButton:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #status {
            color: gray;
            font-size: 0.9em;
            margin-top: 5px;
        }


    </style>
</head>
<body>

    <div class="fake-video-player-container">
        <div class="video-screen">
            <!-- Canvas for the particle animation AND text -->
            <canvas id="particle-canvas"></canvas>

             <!-- The original HTML text content - HIDDEN -->
             <div class="video-content">
                <h1>12星座 都是這樣黏另一半的</h1>

                <ul>
                    <li>🥰 牡羊座：每天跟你貼貼</li>
                    <li>🥰 金牛座：出門都要牽手</li>
                    <li>🥰 雙子座：整天親親抱抱</li>
                    <li>🥰 巨蟹座：放假就黏一起</li>
                    <li>🥰 獅子座：你回家才肯睡</li>
                    <li>🥰 處女座：照三餐傳訊息</li>
                    <li>🥰 天秤座：上廁所都要跟</li>
                    <li>🥰 天蠍座：整天黏在床上</li>
                    <li>🥰 射手座：出門都要帶你</li>
                    <li>🥰 魔羯座：隨時都要報備</li>
                    <li>🥰 水瓶座：天天把你榨乾</li>
                    <li>🥰 雙魚座：堅持每天見面</li>
                </ul>
            </div>
        </div>
        <div class="fake-controls">
             <div class="play-placeholder"></div>
             <div class="control-placeholder"></div>
             <div class="control-placeholder"></div>
             <div class="control-placeholder"></div>
        </div>
    </div>

    <!-- Download section fixed at the bottom -->
    <div class="download-section">
        <button id="downloadButton">下載假影片 (含文字 5秒)</button>
        <p id="status" style="color: gray; font-size: 0.9em;"></p>
    </div>


    <script>
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        const downloadButton = document.getElementById('downloadButton');
        const statusText = document.getElementById('status');
        const videoContentDiv = document.querySelector('.video-content');

        let particles = [];
        const numberOfParticles = 60;
        let animationId;
        let mediaRecorder;
        const recordedChunks = [];
        const videoDuration = 5000; // 5 seconds in milliseconds

        // Get text content from the hidden HTML
        const titleText = videoContentDiv.querySelector('h1').textContent;
        const listItems = Array.from(videoContentDiv.querySelectorAll('li')).map(li => li.textContent);

        // Get device pixel ratio
        const devicePixelRatio = window.devicePixelRatio || 1;

        // Particle class (same as before)
        class Particle {
            constructor(x, y, size, speedX, speedY) {
                this.x = x;
                this.y = y;
                this.size = size;
                const alpha = Math.random() * 0.5 + 0.2;
                this.color = 'rgba(255, 255, 255, ' + alpha + ')';
                this.speedX = speedX;
                this.speedY = speedY;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                 // Wrap around based on unscaled logical dimensions (handled by context scale)
                const unscaledWidth = canvas.width / devicePixelRatio;
                const unscaledHeight = canvas.height / devicePixelRatio;
                if (this.x < 0 - this.size) this.x = unscaledWidth + this.size;
                if (this.x > unscaledWidth + this.size) this.x = 0 - this.size;
                if (this.y < 0 - this.size) this.y = unscaledHeight + this.size;
                if (this.y > unscaledHeight + this.size) this.y = 0 - this.size;
            }
        }


        // Initialize particles and size canvas
        function initParticles() {
            particles = [];
            const screenElement = canvas.parentElement;
            const displayWidth = screenElement.clientWidth;
            const displayHeight = screenElement.clientHeight;

            // Set the canvas's *internal* dimensions based on device pixel ratio
            canvas.width = displayWidth * devicePixelRatio;
            canvas.height = displayHeight * devicePixelRatio;

            // Set the canvas's *displayed* size using CSS styles
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';

            // Scale the drawing context to match the device pixel ratio
            ctx.scale(devicePixelRatio, devicePixelRatio);

            // Re-initialize particles for the new (unscaled logical) size
             for (let i = 0; i < numberOfParticles; i++) {
                const size = Math.random() * 2 + 1; // Unscaled size
                const x = Math.random() * displayWidth; // Unscaled position
                const y = Math.random() * displayHeight; // Unscaled position
                const speed = Math.random() * 0.8 + 0.1; // Unscaled speed
                const angle = Math.random() * Math.PI * 2; // Random direction
                const speedX = Math.cos(angle) * speed;
                const speedY = Math.sin(angle) * speed;

                particles.push(new Particle(x, y, size, speedX, speedY));
            }

        }

        // Animation loop
        function animate() {
            // Clear canvas with a slightly transparent black to create trails
            // Use the unscaled display dimensions for clearing area
            const screenElement = canvas.parentElement;
            const displayWidth = screenElement.clientWidth;
            const displayHeight = screenElement.clientHeight;

            ctx.fillStyle = 'rgba(17, 17, 17, 0.1)';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            // Draw particles
            for (let i = 0; i < particles.length; i++) {
                particles[i].update(); // Updates using unscaled speeds
                particles[i].draw(); // Draws using scaled context on unscaled positions
            }

            // --- Draw Text on Canvas ---
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; // Center text horizontally

            const screenPaddingHorizontal = 15; // Unscaled horizontal padding/margin
            const centerX = displayWidth / 2; // Center in unscaled coordinates
            const availableWidth = displayWidth - 2 * screenPaddingHorizontal; // Unscaled width for text

            // Adjust the initial Y position for the title to be higher
            // ~2cm from the top of the screen area
            let startY = 105; // Still 105 from previous adjustment

            // Draw Title
            const titleFontSize = 24; // Unscaled font size (pixels)
            ctx.font = `bold ${titleFontSize}px sans-serif`; // Use unscaled font size here
            const titleWidth = ctx.measureText(titleText).width / devicePixelRatio; // Unscaled width

            // Optional: Check if title is too wide for the safe area
            if (titleWidth > availableWidth) {
                 console.warn('Title text is too wide for the safe area (', titleWidth.toFixed(0), 'px vs', availableWidth.toFixed(0), 'px available). It may overlap the "invisible margin".');
                 // If you needed truncation: titleText = truncateText(ctx, titleText, availableWidth);
            }

            ctx.fillText(titleText, centerX, startY);
            startY += 40; // Unscaled space after title (adjust based on title height)

            // Draw List Items
            const listItemFontSize = 18; // Unscaled font size (pixels)
            ctx.font = `${listItemFontSize}px sans-serif`; // Use unscaled font size here
            const lineHeight = 25; // Unscaled space between list items (adjust as needed)
            const screenPaddingVertical = 15; // Unscaled vertical padding at bottom

            for (let i = 0; i < listItems.length; i++) {
                const item = listItems[i];
                 const itemWidth = ctx.measureText(item).width / devicePixelRatio; // Unscaled width

                 // Optional: Check if list item is too wide
                 if (itemWidth > availableWidth) {
                     console.warn('List item text is too wide for the safe area (', itemWidth.toFixed(0), 'px vs', availableWidth.toFixed(0), 'px available). It may overlap the "invisible margin":', item);
                     // If you needed truncation: item = truncateText(ctx, item, availableWidth);
                 }

                 // Check if item will fit vertically before drawing
                if (startY + i * lineHeight > displayHeight - screenPaddingVertical) {
                     break; // Stop drawing if out of space
                }
                ctx.fillText(item, centerX, startY + i * lineHeight);
            }
             // --- End Draw Text on Canvas ---


            animationId = requestAnimationFrame(animate);
        }

        // --- MediaRecorder Setup ---

        function startRecording() {
            statusText.textContent = "正在錄製影片 (5秒)...";
            downloadButton.disabled = true;
            recordedChunks.length = 0;

            try {
                // Attempt to capture a stream from the canvas
                // The stream resolution will be the internal canvas.width/height, which is high-res
                const stream = canvas.captureStream(60); // Capture at 60 frames per second

                // Create a MediaRecorder instance
                const options = { mimeType: 'video/webm; codecs=vp9' };
                 if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                     options.mimeType = 'video/webm; codecs=vp8';
                      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                          options.mimeType = 'video/webm';
                           if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                               options.mimeType = 'video/ogg; codecs=theora';
                                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                                    statusText.textContent = "錯誤：瀏覽器不支援錄影功能。";
                                    downloadButton.disabled = false;
                                    console.error('MediaRecorder not supported in this browser.');
                                    return;
                                }
                           }
                      }
                 }

                mediaRecorder = new MediaRecorder(stream, options);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    statusText.textContent = "錄製完成，正在準備下載...";
                    const blob = new Blob(recordedChunks, { type: options.mimeType });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'zodiac_video.webm';
                    document.body.appendChild(a);

                    a.click();

                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    statusText.textContent = "下載開始 (請檢查您的下載資料夾)";
                    downloadButton.disabled = false;
                };

                mediaRecorder.start();

                setTimeout(() => {
                    if (mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                    }
                }, videoDuration);

            } catch (e) {
                statusText.textContent = "錄影失敗: " + e;
                downloadButton.disabled = false;
                console.error('Error starting mediaRecorder:', e);
            }
        }


        // --- Event Listeners and Initial Setup ---

        // Handle window resize - re-initialize particles and canvas size
        window.addEventListener('resize', initParticles);

        // Download button click handler
        downloadButton.addEventListener('click', startRecording);

        // Initial setup
        initParticles(); // Initialize particles and canvas size with device pixel ratio
        animate(); // Start the particle animation loop (which also draws text)


    </script>

</body>
</html>
