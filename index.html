<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12æ˜Ÿåº§ é»å¦ä¸€åŠ (å‡å½±ç‰‡æ’­æ”¾å™¨ å«ç²’å­ä¸‹è¼‰ - ç°¡æ˜“ç‰ˆ)</title>
    <style>
        body {
            background-color: black; /* Black background for the whole page */
            color: white; /* Default text color */
            font-family: sans-serif; /* Readable font */
            margin: 0; /* Remove default body margin */
            padding: 20px; /* Add some padding around content */
            padding-bottom: 80px; /* Add padding at the bottom to prevent content hiding behind fixed button */
            box-sizing: border-box;
            display: flex; /* Use flexbox to center the player */
            justify-content: center; /* Center horizontally */
            align-items: flex-start; /* Align items to the start (top) so player isn't always vertically centered */
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            overflow-y: auto; /* Add scroll if content overflows */
            overflow-x: hidden; /* Hide horizontal scrollbar if player is slightly too wide */
        }

        .fake-video-player-container {
            max-width: 350px; /* Set a max width for the player (typical for 9:16 on desktop) */
            width: 90%; /* Player takes up 90% of container width, up to max-width */
            background-color: #222; /* Dark background for the player frame */
            border-radius: 15px; /* Rounded corners for the player */
            overflow: hidden; /* Hide anything that spills out */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); /* Add a subtle shadow */
            display: flex; /* Arrange screen and controls vertically */
            flex-direction: column;
            margin-top: 20px; /* Add some margin at the top */
        }

        .video-screen {
            position: relative;
            width: 100%;
            aspect-ratio: 9 / 16; /* KEEPS 9:16 */
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .video-content {
            display: none; /* The original HTML text content - HIDDEN */
        }

        .fake-controls {
            background-color: #333;
            height: 40px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
            z-index: 10;
        }

        .fake-controls .control-placeholder {
            width: 20px;
            height: 20px;
            background-color: #555;
            border-radius: 3px;
        }

        .fake-controls .play-placeholder {
             width: 25px;
             height: 25px;
             background-color: #eee;
             border-radius: 50%;
        }

        .download-section {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 0;
            text-align: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        #downloadButton {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        #downloadButton:hover:not(:disabled) {
            background-color: #0056b3;
        }

         #downloadButton:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #status {
            color: gray;
            font-size: 0.9em;
            margin-top: 5px;
            min-height: 1.1em; /* Ensure space for status text */
        }


    </style>
</head>
<body>

    <div class="fake-video-player-container">
        <div class="video-screen">
            <!-- Canvas for the particle animation AND text -->
            <canvas id="particle-canvas"></canvas>

             <!-- The original HTML text content - HIDDEN -->
             <div class="video-content">
                <h1>12æ˜Ÿåº§ éƒ½æ˜¯é€™æ¨£é»å¦ä¸€åŠçš„</h1>

                <ul>
                    <li>ğŸ¥° ç‰¡ç¾Šåº§ï¼šæ¯å¤©è·Ÿä½ è²¼è²¼</li>
                    <li>ğŸ¥° é‡‘ç‰›åº§ï¼šå‡ºé–€éƒ½è¦ç‰½æ‰‹</li>
                    <li>ğŸ¥° é›™å­åº§ï¼šæ•´å¤©è¦ªè¦ªæŠ±æŠ±</li>
                    <li>ğŸ¥° å·¨èŸ¹åº§ï¼šæ”¾å‡å°±é»ä¸€èµ·</li>
                    <li>ğŸ¥° ç…å­åº§ï¼šä½ å›å®¶æ‰è‚¯ç¡</li>
                    <li>ğŸ¥° è™•å¥³åº§ï¼šç…§ä¸‰é¤å‚³è¨Šæ¯</li>
                    <li>ğŸ¥° å¤©ç§¤åº§ï¼šä¸Šå»æ‰€éƒ½è¦è·Ÿ</li>
                    <li>ğŸ¥° å¤©è åº§ï¼šæ•´å¤©é»åœ¨åºŠä¸Š</li>
                    <li>ğŸ¥° å°„æ‰‹åº§ï¼šå‡ºé–€éƒ½è¦å¸¶ä½ </li>
                    <li>ğŸ¥° é­”ç¾¯åº§ï¼šéš¨æ™‚éƒ½è¦å ±å‚™</li>
                    <li>ğŸ¥° æ°´ç“¶åº§ï¼šå¤©å¤©æŠŠä½ æ¦¨ä¹¾</li>
                    <li>ğŸ¥° é›™é­šåº§ï¼šå …æŒæ¯å¤©è¦‹é¢</li>
                </ul>
            </div>
        </div>
        <div class="fake-controls">
             <div class="play-placeholder"></div>
             <div class="control-placeholder"></div>
             <div class="control-placeholder"></div>
             <div class="control-placeholder"></div>
        </div>
    </div>

    <!-- Download section fixed at the bottom -->
    <div class="download-section">
        <button id="downloadButton">ä¸‹è¼‰å½±ç‰‡ (ç°¡æ˜“ç‰ˆ)</button>
        <p id="status"></p>
    </div>


    <script>
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        const downloadButton = document.getElementById('downloadButton');
        const statusText = document.getElementById('status');
        const videoContentDiv = document.querySelector('.video-content');

        let particles = [];
        const numberOfParticles = 60;
        let animationId;
        let mediaRecorder;
        const recordedChunks = [];
        const videoDuration = 5000; // 5 seconds in milliseconds

        // Get text content from the hidden HTML
        const titleText = videoContentDiv.querySelector('h1').textContent;
        const listItems = Array.from(videoContentDiv.querySelectorAll('li')).map(li => li.textContent);

        // Get device pixel ratio
        const devicePixelRatio = window.devicePixelRatio || 1;

        // Particle class (same as before)
        class Particle {
            constructor(x, y, size, speedX, speedY) {
                this.x = x;
                this.y = y;
                this.size = size;
                const alpha = Math.random() * 0.5 + 0.2;
                this.color = 'rgba(255, 255, 255, ' + alpha + ')';
                this.speedX = speedX;
                this.speedY = speedY;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                 // Wrap around based on unscaled logical dimensions (handled by context scale)
                const unscaledWidth = canvas.width / devicePixelRatio;
                const unscaledHeight = canvas.height / devicePixelRatio;
                if (this.x < 0 - this.size) this.x = unscaledWidth + this.size;
                if (this.x > unscaledWidth + this.size) this.x = 0 - this.size;
                if (this.y < 0 - this.size) this.y = unscaledHeight + this.size;
                if (this.y > unscaledHeight + this.size) this.y = 0 - this.size;
            }
        }


        // Initialize particles and size canvas
        function initParticles() {
            particles = [];
            const screenElement = canvas.parentElement;
            const displayWidth = screenElement.clientWidth;
            const displayHeight = screenElement.clientHeight;

            // Set the canvas's *internal* dimensions based on device pixel ratio
            canvas.width = displayWidth * devicePixelRatio;
            canvas.height = displayHeight * devicePixelRatio;

            // Set the canvas's *displayed* size using CSS styles
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';

            // Scale the drawing context to match the device pixel ratio
            // Reset transform first to avoid accumulating scaling
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(devicePixelRatio, devicePixelRatio);

             console.log(`Canvas initialized: ${canvas.width}x${canvas.height} internal, ${displayWidth}x${displayHeight} displayed.`);


            // Re-initialize particles for the new (unscaled logical) size
             for (let i = 0; i < numberOfParticles; i++) {
                const size = Math.random() * 2 + 1; // Unscaled size
                const x = Math.random() * displayWidth; // Unscaled position
                const y = Math.random() * displayHeight; // Unscaled position
                const speed = Math.random() * 0.8 + 0.1; // Unscaled speed
                const angle = Math.random() * Math.PI * 2; // Random direction
                const speedX = Math.cos(angle) * speed;
                const speedY = Math.sin(angle) * speed;

                particles.push(new Particle(x, y, size, speedX, speedY));
            }

        }

        // Draw everything on the canvas (particles and text)
        function drawCanvas() {
            const screenElement = canvas.parentElement;
            const displayWidth = screenElement.clientWidth;
            const displayHeight = screenElement.clientHeight;

            // Clear canvas with a slightly transparent black to create trails
            ctx.fillStyle = 'rgba(17, 17, 17, 0.1)';
            // When using setTransform/scale, clearing with the unscaled dimensions works correctly
            ctx.fillRect(0, 0, displayWidth, displayHeight);


            // Draw particles
            for (let i = 0; i < particles.length; i++) {
                particles[i].draw(); // Draws using scaled context on unscaled positions
            }

            // --- Draw Text on Canvas ---
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; // Center text horizontally

            const screenPaddingHorizontal = 15; // Unscaled horizontal padding/margin
            const centerX = displayWidth / 2; // Center in unscaled coordinates
            const availableWidth = displayWidth - 2 * screenPaddingHorizontal; // Unscaled width for text

            // Initial Y position for the title (adjusted)
            let startY = 105; // Base startY

            // Draw Title
            const titleFontSize = 24; // Unscaled font size (pixels)
            ctx.font = `bold ${titleFontSize}px sans-serif`; // Use unscaled font size here
            const titleWidth = ctx.measureText(titleText).width; // Unscaled width (measureText is affected by ctx.scale)

            if (titleWidth > availableWidth) {
                 console.warn('Title text is too wide for the safe area (', titleWidth.toFixed(0), 'px vs', availableWidth.toFixed(0), 'px available).');
            }

            // Add a text shadow for better contrast if needed
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            ctx.fillText(titleText, centerX, startY);

            // Reset shadow for subsequent drawings
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;


            startY += 40; // Unscaled space after title

            // Draw List Items
            const listItemFontSize = 18; // Unscaled font size (pixels)
            ctx.font = `${listItemFontSize}px sans-serif`; // Use unscaled font size here
            const lineHeight = 25; // Unscaled space between list items (adjust as needed)
            const screenPaddingVertical = 15; // Unscaled vertical padding at bottom

             // Reset shadow for list items if it was applied above
             ctx.shadowColor = 'transparent';
             ctx.shadowBlur = 0;


            for (let i = 0; i < listItems.length; i++) {
                const item = listItems[i];
                const itemWidth = ctx.measureText(item).width; // Unscaled width

                if (itemWidth > availableWidth) {
                     console.warn('List item text is too wide for the safe area (', itemWidth.toFixed(0), 'px vs', availableWidth.toFixed(0), 'px available):', item);
                 }

                // Check if item will fit vertically before drawing - use unscaled coordinates
                if (startY + i * lineHeight > displayHeight - screenPaddingVertical) {
                     break; // Stop drawing if out of space
                }
                ctx.fillText(item, centerX, startY + i * lineHeight);
            }
             // --- End Draw Text on Canvas ---
        }

        // Main particle animation loop (draws everything)
        function animate() {
             // Update particle positions
             for (let i = 0; i < particles.length; i++) {
                particles[i].update();
             }
             // Redraw the entire canvas
            drawCanvas();
            animationId = requestAnimationFrame(animate);
        }

        // --- MediaRecorder Setup (Simple Download) ---

        function startRecording() {
            statusText.textContent = "æ­£åœ¨éŒ„è£½å½±ç‰‡ (5ç§’)...";
            downloadButton.disabled = true;
            recordedChunks.length = 0; // Clear previous data

            try {
                // Attempt to capture a stream from the canvas
                // Use default frame rate for potentially better stability vs 60fps
                const stream = canvas.captureStream(); // CAPTURING AT BROWSER DEFAULT FRAME RATE (approx 30fps)

                 // Define preferred MIME types in order (MP4 first, then WebM fallbacks)
                const preferredMimeTypes = [
                    // Try H.264 MP4 first (support varies widely for canvas recording)
                    'video/mp4; codecs="avc1.42001E"', // Specific H.264 profile, might have better luck
                    'video/mp4; codecs=avc1', // Generic H.264
                    'video/mp4', // Just MP4
                    'video/webm; codecs=vp9', // High quality WebM
                    'video/webm; codecs=vp8', // Older WebM
                    'video/webm', // Generic WebM
                    'video/ogg; codecs=theora' // Ogg fallback
                ];

                let supportedMimeType = null;
                for (let i = 0; i < preferredMimeTypes.length; i++) {
                    if (MediaRecorder.isTypeSupported(preferredMimeTypes[i])) {
                        supportedMimeType = preferredMimeTypes[i];
                        break; // Use the first supported type found
                    }
                }

                if (!supportedMimeType) {
                    statusText.textContent = "éŒ¯èª¤ï¼šç€è¦½å™¨ä¸æ”¯æ´ä»»ä½•éŒ„å½±æ ¼å¼ã€‚";
                    downloadButton.disabled = false;
                    console.error('MediaRecorder supported type not found.');
                    return;
                }

                const options = { mimeType: supportedMimeType };
                 console.log("Using MIME type:", supportedMimeType); // Log which type was chosen


                mediaRecorder = new MediaRecorder(stream, options);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    statusText.textContent = "éŒ„è£½å®Œæˆï¼Œæ­£åœ¨æº–å‚™ä¸‹è¼‰...";
                    const blob = new Blob(recordedChunks, { type: supportedMimeType }); // Use the actual supported type for the Blob
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;

                    // Determine file extension based on the chosen MIME type
                    let fileExtension = '.webm'; // Default to webm
                    if (supportedMimeType.includes('mp4')) {
                        fileExtension = '.mp4';
                    } else if (supportedMimeType.includes('ogg')) {
                         fileExtension = '.ogv'; // Ogg video extension
                    }
                    a.download = 'zodiac_video' + fileExtension; // Set download filename

                    document.body.appendChild(a);

                    a.click();

                    // Clean up
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    statusText.textContent = "ä¸‹è¼‰é–‹å§‹ (è«‹æª¢æŸ¥æ‚¨çš„ä¸‹è¼‰è³‡æ–™å¤¾)";
                    downloadButton.disabled = false;
                };

                mediaRecorder.start();

                // Stop recording after 5 seconds
                setTimeout(() => {
                    if (mediaRecorder.state !== 'inactive') {
                        mediaRecorder.stop();
                    }
                }, videoDuration);

            } catch (e) {
                statusText.textContent = "éŒ„å½±å¤±æ•—: " + e;
                downloadButton.disabled = false;
                console.error('Error starting mediaRecorder:', e);
            }
        }


        // --- Event Listeners and Initial Setup ---

        // Handle window resize - re-initialize particles and canvas size
        window.addEventListener('resize', initParticles);

        // Download button click handler
        downloadButton.addEventListener('click', startRecording);

        // Initial setup
        initParticles(); // Initialize particles and canvas size with device pixel ratio
        animate(); // Start the particle animation loop (which also draws text)


    </script>

</body>
</html>
